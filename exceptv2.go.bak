package except

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"reflect"
	"runtime"
	"strings"
)

// X is the main auto-detecting error handler
// Usage: except.X(err)
// Usage: except.X(err, filename)
// Usage: except.X(err, "processing", filename)
// Usage: except.X(err, map[string]interface{}{"file": filename, "op": "read"})
func X(err error, context ...interface{}) error {
	if err == nil {
		return nil
	}

	// Build smart context
	info := buildSmartErrorInfo(err, context...)
	Catch.handleError(info)
	return err
}

// buildSmartErrorInfo creates comprehensive error info with auto-detection
func buildSmartErrorInfo(err error, context ...interface{}) ErrorInfo {
	config := Catch.getConfig()

	// Get caller information
	pc, file, line, ok := runtime.Caller(2) // Skip X() and buildSmartErrorInfo()
	if !ok {
		file = "unknown"
		line = 0
	}

	var funcName string
	if fn := runtime.FuncForPC(pc); fn != nil {
		funcName = fn.Name()
		if lastSlash := strings.LastIndex(funcName, "/"); lastSlash >= 0 {
			funcName = funcName[lastSlash+1:]
		}
	}

	info := ErrorInfo{
		Error:      err,
		File:       file,
		Line:       line,
		Function:   funcName,
		Context:    make(map[string]interface{}),
		ErrorCode:  generateSmartErrorCode(err),
		Suggestion: generateSmartSuggestion(err),
	}

	// Auto-detect and build context
	info.Context = buildSmartContext(file, line, context...)

	// Load source code context if enabled
	if config.ShowSourceCode {
		info.SourceLines = Catch.loadSourceContext(file, line, config.ContextLines)
	}

	// Build stack trace if enabled
	if config.ShowStackTrace {
		info.Stack = Catch.buildStackTrace(1)
	}

	return info
}

// buildSmartContext auto-detects context from various sources
func buildSmartContext(file string, line int, context ...interface{}) map[string]interface{} {
	ctx := make(map[string]interface{})

	// 1. Parse provided context
	ctx = parseProvidedContext(ctx, context...)

	// 2. Auto-detect from source code
	sourceCtx := detectContextFromSource(file, line)
	for k, v := range sourceCtx {
		if _, exists := ctx[k]; !exists { // Don't override explicit context
			ctx[k] = v
		}
	}

	// 3. Auto-detect from stack trace
	stackCtx := detectContextFromStack()
	for k, v := range stackCtx {
		if _, exists := ctx[k]; !exists {
			ctx[k] = v
		}
	}

	return ctx
}

// parseProvidedContext handles various context input formats
func parseProvidedContext(ctx map[string]interface{}, context ...interface{}) map[string]interface{} {
	if len(context) == 0 {
		return ctx
	}

	// Handle map[string]interface{} directly
	if len(context) == 1 {
		if m, ok := context[0].(map[string]interface{}); ok {
			for k, v := range m {
				ctx[k] = v
			}
			return ctx
		}
	}

	// Handle key-value pairs or auto-name values
	for i, item := range context {
		switch v := item.(type) {
		case string:
			if i+1 < len(context) && i%2 == 0 {
				// String followed by value = key-value pair
				ctx[v] = context[i+1]
				continue
			}
			// Standalone string = operation or description
			if strings.Contains(v, "/") || strings.Contains(v, ".") {
				ctx["path"] = v
			} else {
				ctx["operation"] = v
			}
		case int, int64, float64:
			ctx[fmt.Sprintf("value_%d", i)] = v
		default:
			// Try to infer meaning from type
			ctx[inferContextKey(v)] = v
		}
	}

	return ctx
}

// inferContextKey tries to guess appropriate key names
func inferContextKey(value interface{}) string {
	switch v := value.(type) {
	case string:
		if strings.Contains(v, "/") || strings.Contains(v, ".") {
			return "path"
		}
		if len(v) < 20 {
			return "name"
		}
		return "description"
	case *os.File:
		return "file"
	default:
		t := reflect.TypeOf(value)
		if t != nil {
			return strings.ToLower(t.Name())
		}
		return "context"
	}
}

// detectContextFromSource analyzes source code around error line
func detectContextFromSource(filename string, errorLine int) map[string]interface{} {
	ctx := make(map[string]interface{})

	// Parse the source file
	fset := token.NewFileSet()
	src, err := os.ReadFile(filename)
	if err != nil {
		return ctx
	}

	file, err := parser.ParseFile(fset, filename, src, parser.ParseComments)
	if err != nil {
		return ctx
	}

	// Find variables and function calls near the error line
	ast.Inspect(file, func(n ast.Node) bool {
		if n == nil {
			return false
		}

		pos := fset.Position(n.Pos())
		if abs(pos.Line-errorLine) <= 2 { // Within 2 lines of error
			switch node := n.(type) {
			case *ast.CallExpr:
				// Detect function calls like os.Open(filename)
				if ident, ok := node.Fun.(*ast.SelectorExpr); ok {
					if x, ok := ident.X.(*ast.Ident); ok {
						funcName := fmt.Sprintf("%s.%s", x.Name, ident.Sel.Name)
						ctx["function_call"] = funcName

						// Extract arguments
						for i, arg := range node.Args {
							if ident, ok := arg.(*ast.Ident); ok {
								ctx[fmt.Sprintf("arg_%d_%s", i, ident.Name)] = ident.Name

								// Common patterns
								if strings.Contains(ident.Name, "file") || strings.Contains(ident.Name, "path") {
									ctx["target_file"] = ident.Name
								}
							}
						}
					}
				}
			case *ast.AssignStmt:
				// Detect assignments like file, err := os.Open(...)
				for _, expr := range node.Lhs {
					if ident, ok := expr.(*ast.Ident); ok {
						if ident.Name != "err" {
							ctx["assigned_var"] = ident.Name
						}
					}
				}
			}
		}
		return true
	})

	return ctx
}

// detectContextFromStack analyzes stack frames for patterns
func detectContextFromStack() map[string]interface{} {
	ctx := make(map[string]interface{})

	// Look at calling functions
	for i := 3; i < 8; i++ { // Skip our internal calls
		pc, file, line, ok := runtime.Caller(i)
		if !ok {
			break
		}

		if fn := runtime.FuncForPC(pc); fn != nil {
			funcName := fn.Name()

			// Clean function name
			if lastSlash := strings.LastIndex(funcName, "/"); lastSlash >= 0 {
				funcName = funcName[lastSlash+1:]
			}

			// Detect patterns in function names
			lower := strings.ToLower(funcName)
			switch {
			case strings.Contains(lower, "read"):
				ctx["operation_type"] = "read"
			case strings.Contains(lower, "write"):
				ctx["operation_type"] = "write"
			case strings.Contains(lower, "open"):
				ctx["operation_type"] = "open"
			case strings.Contains(lower, "process"):
				ctx["operation_type"] = "process"
			case strings.Contains(lower, "handle"):
				ctx["operation_type"] = "handle"
			}

			// Add calling context
			ctx["caller_function"] = funcName
			ctx["caller_location"] = fmt.Sprintf("%s:%d", filepath.Base(file), line)
			break
		}
	}

	return ctx
}

// generateSmartErrorCode creates context-aware error codes
func generateSmartErrorCode(err error) string {
	errStr := strings.ToLower(err.Error())

	// File system errors
	switch {
	case strings.Contains(errStr, "no such file"):
		return "FS001"
	case strings.Contains(errStr, "permission denied"):
		return "FS002"
	case strings.Contains(errStr, "file exists"):
		return "FS003"
	case strings.Contains(errStr, "is a directory"):
		return "FS004"
	case strings.Contains(errStr, "not a directory"):
		return "FS005"

	// Network errors
	case strings.Contains(errStr, "connection refused"):
		return "NET001"
	case strings.Contains(errStr, "timeout"):
		return "NET002"
	case strings.Contains(errStr, "host not found"):
		return "NET003"
	case strings.Contains(errStr, "network unreachable"):
		return "NET004"

	// Data errors
	case strings.Contains(errStr, "parse"):
		return "DATA001"
	case strings.Contains(errStr, "invalid format"):
		return "DATA002"
	case strings.Contains(errStr, "decode"):
		return "DATA003"
	case strings.Contains(errStr, "encode"):
		return "DATA004"

	// Logic errors
	case strings.Contains(errStr, "index out of range"):
		return "LOGIC001"
	case strings.Contains(errStr, "nil pointer"):
		return "LOGIC002"
	case strings.Contains(errStr, "assertion failed"):
		return "LOGIC003"

	// Generic
	default:
		return "GEN000"
	}
}

// generateSmartSuggestion creates context-aware suggestions
func generateSmartSuggestion(err error) string {
	errStr := strings.ToLower(err.Error())

	switch {
	case strings.Contains(errStr, "no such file"):
		return "verify the file path exists, check for typos, or create the file first"
	case strings.Contains(errStr, "permission denied"):
		return "run with appropriate permissions, check file ownership, or modify file permissions"
	case strings.Contains(errStr, "connection refused"):
		return "ensure the target service is running, check firewall settings, or verify the address and port"
	case strings.Contains(errStr, "timeout"):
		return "increase timeout duration, check network connectivity, or optimize the operation"
	case strings.Contains(errStr, "parse"):
		return "validate input format, check for encoding issues, or review the data structure"
	case strings.Contains(errStr, "index out of range"):
		return "add bounds checking, validate array/slice length, or review loop conditions"
	case strings.Contains(errStr, "nil pointer"):
		return "add nil checks, initialize variables properly, or review pointer assignments"
	default:
		return "check the error context, consult documentation, or add debug logging"
	}
}

// abs returns absolute value of an integer
func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

// Additional convenience functions that work with X()

// Xf formats and handles error with context
// Usage: except.Xf(err, "failed to process %s", filename)
func Xf(err error, format string, args ...interface{}) error {
	if err == nil {
		return nil
	}

	wrappedErr := fmt.Errorf(format+": %w", append(args, err)...)
	return X(wrappedErr, args...)
}

// XMust panics with smart error info if err is not nil
// Usage: file := except.XMust(os.Open(filename))
func XMust[T any](val T, err error) T {
	if err != nil {
		X(err) // This will exit due to default config
	}
	return val
}

// XCheck returns false and handles error if not nil
// Usage: if !except.XCheck(err) { return }
func XCheck(err error) bool {
	if err != nil {
		X(err)
		return false
	}
	return true
}

// Examples of usage:
/*
// Ultra simple - auto-detects everything
except.X(err)

// With explicit context
except.X(err, filename)
except.X(err, "file_processing", filename)
except.X(err, map[string]interface{}{"file": filename, "operation": "read"})

// Auto-formatting
except.Xf(err, "failed to process %s", filename)

// Must pattern
file := except.XMust(os.Open(filename))

// Check pattern
if !except.XCheck(err) { return }
*/
