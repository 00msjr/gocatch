package except

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strings"
)

// Catch is a global variable that can be used to catch and handle errors
var Catch = ErrorCatcher{}

// ErrorConfig holds configuration for error handling
type ErrorConfig struct {
	ShowStackTrace  bool
	ShowSourceCode  bool
	ShowSuggestions bool
	ExitOnError     bool
	LogToFile       string
	MaxStackDepth   int
	ContextLines    int
	UseColors       bool
}

// DefaultConfig provides sensible defaults with Rust-like formatting
var DefaultConfig = ErrorConfig{
	ShowStackTrace:  true,
	ShowSourceCode:  true,
	ShowSuggestions: true,
	ExitOnError:     true,
	MaxStackDepth:   10,
	ContextLines:    2,
	UseColors:       true,
}

// ErrorCatcher is a type that can be used to catch and handle errors
type ErrorCatcher struct {
	Config ErrorConfig
}

// Enhanced error information
type ErrorInfo struct {
	Error       error
	File        string
	Line        int
	Column      int
	Function    string
	Context     map[string]interface{}
	Stack       []StackFrame
	SourceLines []SourceLine
	ErrorCode   string
	Suggestion  string
}

type StackFrame struct {
	File     string
	Line     int
	Function string
}

type SourceLine struct {
	Number  int
	Content string
	IsError bool
}

// ANSI color codes
const (
	Reset     = "\033[0m"
	Bold      = "\033[1m"
	Red       = "\033[31m"
	Green     = "\033[32m"
	Yellow    = "\033[33m"
	Blue      = "\033[34m"
	Magenta   = "\033[35m"
	Cyan      = "\033[36m"
	White     = "\033[37m"
	BrightRed = "\033[91m"
	Gray      = "\033[90m"
)

// Configure sets the error handling configuration
func (e *ErrorCatcher) Configure(config ErrorConfig) *ErrorCatcher {
	e.Config = config
	return e
}

// WithContext adds contextual information to error handling
func (e ErrorCatcher) WithContext(key string, value interface{}) *ContextualCatcher {
	return &ContextualCatcher{
		catcher: e,
		context: map[string]interface{}{key: value},
	}
}

// ContextualCatcher allows chaining context information
type ContextualCatcher struct {
	catcher ErrorCatcher
	context map[string]interface{}
}

// WithContext adds more context to the chain
func (c *ContextualCatcher) WithContext(key string, value interface{}) *ContextualCatcher {
	c.context[key] = value
	return c
}

// Set handles error with accumulated context
func (c *ContextualCatcher) Set(err error) error {
	if err != nil {
		info := c.catcher.buildErrorInfo(err, 1)
		info.Context = c.context
		c.catcher.handleError(info)
	}
	return err
}

// buildErrorInfo creates detailed error information with source code context
func (e ErrorCatcher) buildErrorInfo(err error, skip int) ErrorInfo {
	config := e.getConfig()

	// Get caller information
	pc, file, line, ok := runtime.Caller(skip + 1)
	if !ok {
		file = "unknown"
		line = 0
	}

	var funcName string
	if fn := runtime.FuncForPC(pc); fn != nil {
		funcName = fn.Name()
		// Clean up function name (remove package path)
		if lastSlash := strings.LastIndex(funcName, "/"); lastSlash >= 0 {
			funcName = funcName[lastSlash+1:]
		}
	}

	info := ErrorInfo{
		Error:      err,
		File:       file,
		Line:       line,
		Function:   funcName,
		Context:    make(map[string]interface{}),
		ErrorCode:  e.generateErrorCode(err),
		Suggestion: e.generateSuggestion(err),
	}

	// Load source code context if enabled
	if config.ShowSourceCode {
		info.SourceLines = e.loadSourceContext(file, line, config.ContextLines)
	}

	// Build stack trace if enabled
	if config.ShowStackTrace {
		info.Stack = e.buildStackTrace(skip + 1)
	}

	return info
}

// generateErrorCode creates a Rust-style error code
func (e ErrorCatcher) generateErrorCode(err error) string {
	errStr := err.Error()

	// Generate error codes based on common error patterns
	switch {
	case strings.Contains(errStr, "no such file"):
		return "E0001"
	case strings.Contains(errStr, "permission denied"):
		return "E0002"
	case strings.Contains(errStr, "connection refused"):
		return "E0003"
	case strings.Contains(errStr, "timeout"):
		return "E0004"
	case strings.Contains(errStr, "invalid"):
		return "E0005"
	case strings.Contains(errStr, "not found"):
		return "E0006"
	case strings.Contains(errStr, "already exists"):
		return "E0007"
	case strings.Contains(errStr, "parse"):
		return "E0008"
	case strings.Contains(errStr, "assertion failed"):
		return "E0009"
	case strings.Contains(errStr, "index out of range"):
		return "E0010"
	default:
		return "E0000"
	}
}

// generateSuggestion provides helpful suggestions based on error type
func (e ErrorCatcher) generateSuggestion(err error) string {
	errStr := strings.ToLower(err.Error())

	switch {
	case strings.Contains(errStr, "no such file"):
		return "check if the file path is correct and the file exists"
	case strings.Contains(errStr, "permission denied"):
		return "verify you have the necessary permissions to access this resource"
	case strings.Contains(errStr, "connection refused"):
		return "ensure the service is running and the address is correct"
	case strings.Contains(errStr, "timeout"):
		return "try increasing the timeout duration or check network connectivity"
	case strings.Contains(errStr, "invalid"):
		return "validate the input format and ensure all required fields are provided"
	case strings.Contains(errStr, "not found"):
		return "verify the resource exists and the identifier is correct"
	case strings.Contains(errStr, "already exists"):
		return "use a different name or remove the existing resource first"
	case strings.Contains(errStr, "parse"):
		return "check the syntax and format of the input data"
	case strings.Contains(errStr, "assertion failed"):
		return "review the condition logic and input validation"
	case strings.Contains(errStr, "index out of range"):
		return "ensure the index is within the valid range of the collection"
	default:
		return "review the error context and check the documentation"
	}
}

// loadSourceContext reads source code around the error line
func (e ErrorCatcher) loadSourceContext(filename string, errorLine, contextLines int) []SourceLine {
	file, err := os.Open(filename)
	if err != nil {
		return nil
	}
	defer file.Close()

	var lines []SourceLine
	scanner := bufio.NewScanner(file)
	currentLine := 0

	startLine := errorLine - contextLines
	endLine := errorLine + contextLines

	if startLine < 1 {
		startLine = 1
	}

	for scanner.Scan() {
		currentLine++
		if currentLine >= startLine && currentLine <= endLine {
			lines = append(lines, SourceLine{
				Number:  currentLine,
				Content: scanner.Text(),
				IsError: currentLine == errorLine,
			})
		}
		if currentLine > endLine {
			break
		}
	}

	return lines
}

// buildStackTrace creates a stack trace
func (e ErrorCatcher) buildStackTrace(skip int) []StackFrame {
	config := e.getConfig()
	var stack []StackFrame

	for i := skip + 1; i < skip+config.MaxStackDepth; i++ {
		pc, file, line, ok := runtime.Caller(i)
		if !ok {
			break
		}

		var funcName string
		if fn := runtime.FuncForPC(pc); fn != nil {
			funcName = fn.Name()
			if lastSlash := strings.LastIndex(funcName, "/"); lastSlash >= 0 {
				funcName = funcName[lastSlash+1:]
			}
		}

		stack = append(stack, StackFrame{
			File:     file,
			Line:     line,
			Function: funcName,
		})
	}

	return stack
}

// handleError processes and outputs the error in Rust style
func (e ErrorCatcher) handleError(info ErrorInfo) {
	config := e.getConfig()

	var output strings.Builder

	// Rust-style error header
	if config.UseColors {
		output.WriteString(fmt.Sprintf("%serror[%s%s%s]: %s%s%s\n",
			BrightRed, Bold, info.ErrorCode, Reset+BrightRed, Bold, info.Error.Error(), Reset))
	} else {
		output.WriteString(fmt.Sprintf("error[%s]: %s\n", info.ErrorCode, info.Error.Error()))
	}

	// File location with arrow
	filename := filepath.Base(info.File)
	if config.UseColors {
		output.WriteString(fmt.Sprintf(" %s-->%s %s:%d\n", Blue+Bold, Reset, filename, info.Line))
	} else {
		output.WriteString(fmt.Sprintf(" --> %s:%d\n", filename, info.Line))
	}

	// Source code context
	if config.ShowSourceCode && len(info.SourceLines) > 0 {
		output.WriteString("  |\n")

		// Calculate padding for line numbers
		maxLineNum := info.SourceLines[len(info.SourceLines)-1].Number
		padding := len(fmt.Sprintf("%d", maxLineNum))

		for _, sourceLine := range info.SourceLines {
			lineNumStr := fmt.Sprintf("%*d", padding, sourceLine.Number)

			if sourceLine.IsError {
				if config.UseColors {
					output.WriteString(fmt.Sprintf("%s%s%s |%s %s\n",
						Red+Bold, lineNumStr, Reset, Reset, sourceLine.Content))
				} else {
					output.WriteString(fmt.Sprintf("%s | %s\n", lineNumStr, sourceLine.Content))
				}

				// Add error pointer
				spaces := strings.Repeat(" ", padding)
				if config.UseColors {
					output.WriteString(fmt.Sprintf("%s |%s %s%s^\n",
						spaces, Reset, Red+Bold, Reset))
				} else {
					output.WriteString(fmt.Sprintf("%s | ^\n", spaces))
				}
			} else {
				if config.UseColors {
					output.WriteString(fmt.Sprintf("%s%s%s |%s %s%s%s\n",
						Blue, lineNumStr, Reset, Reset, Gray, sourceLine.Content, Reset))
				} else {
					output.WriteString(fmt.Sprintf("%s | %s\n", lineNumStr, sourceLine.Content))
				}
			}
		}
		output.WriteString("  |\n")
	}

	// Add context if available
	if len(info.Context) > 0 {
		if config.UseColors {
			output.WriteString(fmt.Sprintf("  %s=%s %scontext:%s\n", Blue+Bold, Reset, Yellow+Bold, Reset))
		} else {
			output.WriteString("  = context:\n")
		}

		for k, v := range info.Context {
			if config.UseColors {
				output.WriteString(fmt.Sprintf("    %s%s%s: %v\n", Cyan, k, Reset, v))
			} else {
				output.WriteString(fmt.Sprintf("    %s: %v\n", k, v))
			}
		}
		output.WriteString("\n")
	}

	// Add suggestion
	if config.ShowSuggestions && info.Suggestion != "" {
		if config.UseColors {
			output.WriteString(fmt.Sprintf("  %s=%s %shelp:%s %s\n",
				Blue+Bold, Reset, Green+Bold, Reset, info.Suggestion))
		} else {
			output.WriteString(fmt.Sprintf("  = help: %s\n", info.Suggestion))
		}
		output.WriteString("\n")
	}

	// Add stack trace if enabled
	if config.ShowStackTrace && len(info.Stack) > 0 {
		if config.UseColors {
			output.WriteString(fmt.Sprintf("  %s=%s %sstack backtrace:%s\n",
				Blue+Bold, Reset, Yellow+Bold, Reset))
		} else {
			output.WriteString("  = stack backtrace:\n")
		}

		for i, frame := range info.Stack {
			frameFile := filepath.Base(frame.File)
			if config.UseColors {
				output.WriteString(fmt.Sprintf("   %s%2d:%s %s%s%s\n          at %s%s:%d%s\n",
					Gray, i, Reset, Bold, frame.Function, Reset,
					Gray, frameFile, frame.Line, Reset))
			} else {
				output.WriteString(fmt.Sprintf("   %2d: %s\n          at %s:%d\n",
					i, frame.Function, frameFile, frame.Line))
			}
		}
		output.WriteString("\n")
	}

	message := output.String()

	// Output to stderr
	fmt.Fprint(os.Stderr, message)

	// Log to file if configured
	if config.LogToFile != "" {
		e.logToFile(config.LogToFile, message)
	}

	// Exit if configured
	if config.ExitOnError {
		os.Exit(1)
	}
}

// logToFile writes error to a log file (without colors)
func (e ErrorCatcher) logToFile(filename, message string) {
	// Strip ANSI colors for file logging
	cleanMessage := e.stripANSI(message)

	file, err := os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return // Silently fail to avoid infinite recursion
	}
	defer file.Close()

	fmt.Fprint(file, cleanMessage)
}

// stripANSI removes ANSI color codes from text
func (e ErrorCatcher) stripANSI(text string) string {
	// Simple ANSI escape sequence removal
	result := text
	escapes := []string{Reset, Bold, Red, Green, Yellow, Blue, Magenta, Cyan, White, BrightRed, Gray}
	for _, escape := range escapes {
		result = strings.ReplaceAll(result, escape, "")
	}
	return result
}

// getConfig returns the current configuration or default
func (e ErrorCatcher) getConfig() ErrorConfig {
	if e.Config.MaxStackDepth == 0 {
		return DefaultConfig
	}
	return e.Config
}

// Set assigns an error value and handles it if not nil
// Usage: file, err := os.Open(filePath); except.Catch.Set(err)
func (e ErrorCatcher) Set(err error) error {
	if err != nil {
		info := e.buildErrorInfo(err, 1)
		e.handleError(info)
	}
	return err
}

// E is the shortest possible function name for error handling
// Usage: E(err) will check if err is not nil and handle it
func E(err error) {
	if err != nil {
		info := Catch.buildErrorInfo(err, 1)
		Catch.handleError(info)
	}
}

// F is like E but with a custom format string and context
// Usage: F(err, "failed to open %s", filename)
func F(err error, format string, args ...interface{}) {
	if err != nil {
		// Create a wrapped error with the formatted message
		wrappedErr := fmt.Errorf(format+": %w", append(args, err)...)
		info := Catch.buildErrorInfo(wrappedErr, 1)
		Catch.handleError(info)
	}
}

// Wrap creates a new error with additional context without handling it
// Usage: return except.Wrap(err, "failed to process file %s", filename)
func Wrap(err error, format string, args ...interface{}) error {
	if err == nil {
		return nil
	}
	return fmt.Errorf(format+": %w", append(args, err)...)
}

// Must panics if err is not nil with enhanced error info
// Usage: file := Must(os.Open(filename))
func Must[T any](val T, err error) T {
	if err != nil {
		info := Catch.buildErrorInfo(err, 1)
		var msg strings.Builder
		msg.WriteString(fmt.Sprintf("Must failed in %s:%d", filepath.Base(info.File), info.Line))
		if info.Function != "" {
			msg.WriteString(fmt.Sprintf(" (%s)", info.Function))
		}
		msg.WriteString(fmt.Sprintf(": %v", err))
		panic(msg.String())
	}
	return val
}

// Try returns a function that will check the error and handle it
// Usage: defer Try()(&err)
func Try() func(*error) {
	return func(errp *error) {
		if errp != nil && *errp != nil {
			info := Catch.buildErrorInfo(*errp, 2) // Skip 2 levels for defer
			Catch.handleError(info)
		}
	}
}

// Assert checks a condition and creates an error if false
// Usage: except.Assert(len(items) > 0, "items slice cannot be empty")
func Assert(condition bool, message string, args ...interface{}) {
	if !condition {
		err := fmt.Errorf("assertion failed: "+message, args...)
		info := Catch.buildErrorInfo(err, 1)
		Catch.handleError(info)
	}
}

// Check is a convenient function that returns true if error is nil
// Usage: if !except.Check(err) { return }
func Check(err error) bool {
	if err != nil {
		info := Catch.buildErrorInfo(err, 1)
		Catch.handleError(info)
		return false
	}
	return true
}

// Recover handles panics and converts them to errors
// Usage: defer except.Recover()(&err)
func Recover() func(*error) {
	return func(errp *error) {
		if r := recover(); r != nil {
			var err error
			switch v := r.(type) {
			case error:
				err = v
			case string:
				err = fmt.Errorf("panic: %s", v)
			default:
				err = fmt.Errorf("panic: %v", v)
			}

			if errp != nil {
				*errp = err
			} else {
				info := Catch.buildErrorInfo(err, 2)
				Catch.handleError(info)
			}
		}
	}
}
